[{"title":"如何更好的CR？","date":"2020-02-08T15:00:09.000Z","path":"2020/02/08/CR Better/","text":"如何更好的Code Review本文会从 code review 对流程，意义，工具，执行规范四个范畴来进行阐述 意义 发现错误：人都会不可避免的出现一些纰漏，而这些纰漏在另一个人眼中也许显而易见。 健壮性检查：代码是否健壮，是否有潜在安全、性能风险。代码是否可以回滚。 质量保证：保证进入稳定版本的代码是经过层层检查的 统一风格：对于整个团队来说，代码风格的统一很重要。风格统一除了人 Review，我们也引入了静态代码检查，不符合团队风格的代码，是无法通过 CI 的。完善注释：包括 commit message。 交流与学习 范围code review- 函数实现复杂性 - 可阅读性 - 无用的code（可减少的变量声明） - 组件设计优化 logic review针对某个逻辑进行debug式的review，这种情况是否属于 code review 无法界定， 理论上来讲，在做复杂模块设计的时候，会有设计文档生成，设计文档也会经过一遍审查，此时的审查就是复杂逻辑的设计。 执行要点（流程）何时开始code review？理论上在把代码送给测试之前，进行code review，保证送测代码经过开发人员审查通过。 没有修复的issue是否可以送测在code review的时候，评审人员会根据影响范围程度决定是否必要在送测之前修复掉。如果影响甚微，可以在下个迭代的需求中修复掉。 如何优化 code review 的会议时间1. 提前做好code review的`discussion`，这样最大化利用开发者碎片化时间 2. 会议的时候 优先review这些问题，剩下的快速过。并且把相对应的`discussion`转化成`issues`，并标记重要程度 工具Gitlab MR","tags":[{"name":"开发质量","slug":"开发质量","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E8%B4%A8%E9%87%8F/"},{"name":"CR","slug":"CR","permalink":"http://example.com/tags/CR/"}]},{"title":"伟大的前端重构开发工程师","date":"2018-03-23T15:27:39.000Z","path":"2018/03/23/前端重构的基本技能/","text":"🦉伟大的前端重构开发工程师🦉 切图仔难道是很LOW的称号吗？ 写写页面很容易吗？ CSS其实是一门玄学！ 浏览器是切图仔赖以为生的宿主，难道不想跟她谈个恋爱？ 🤡 牛逼切图仔的必备技能我切图，我快乐。 清楚的知道需要切出什么样的图 熟悉一款图像处理的工具 沟通，如何与设计师配合，技术与设计融合理解才能99%的还原设计稿。 为什么叫做切图仔，因为我们需要熟练的掌握PS中的切片利器。如何使用最快的刀法，抠出web使用的素材。有句话叫做庖丁解牛，我们就是那个丁。从拿到设计稿，我们需要全面剖析整个页面的布局，尺寸，以及素材的切法。 大家可能说了，我需要什么素材就直接切咯，干嘛整那么玄乎。 WEB中PNG图片为什么会一般采用PNG8导出呢？ PNG8压缩比更高，兼容IE6的透明背景显示。 我们常说的PNG24，一般都为PS输出，就是PNG32。png32在ie6中的透明化 Photoshop在“存储为WEB格式”中只提供PNG8和PNG24两种PNG格式，既然用到PNG，我们肯定期望导出 的图片是透明的，然后勾选“支持透明”，但是这样你就获取了一张PNG32图片。Photoshop只是觉得把PNG32这个名称给隐藏掉了。 切图时保存什么样的格式？ jpg通常用在颜色复杂、但不要求特别精细的图片上，如照片、宣传图、背景等。 png通常用在颜色复杂并且要求特别精细或者有透明需求的图片上，如复杂的logo、图标等。由于无损还可以当做“原图”来存档使用。 png8兼容ie6 雪碧图（很小的图片（icon）提取到一张png图上）。CSS Sprites 雪碧图应用 这是一个历史性的解决方案，解决请求文件过多、引发性能问题。但是在现在，我们可以切成一个一个小图片，使用构建工具合成雪碧图。不过更加推荐的是把icon制作成图标字体进行使用。这样更便于维护。 如何优雅的切图？cutterman 程序员是这个世界最懒的一群人，软件可以帮我们减少工作量的一定不用手。 🤡 写页面真的不容易你以为会了div+css就Ok了吗？页面布局不仅仅div标签，不仅仅Css定位浮动。 还有，CSS属性的特性、html标签的语义化、W3C的规范（块格式化上下文、层叠上下文、盒子模型等） 还要了解历史圣杯与双飞翼,经常用到的垂直居中。以及你不知道的BFC 还有，你的写的代码是给你的同事阅读的。语义话的结构是不是更适合人类阅读呢？千万别写成酱紫 1234&lt;span&gt; &lt;div&gt;dsds&lt;/div&gt;&lt;/span&gt; 🤡 CSS是一门玄学上面叙述的BFC就是最好的例子，在你看来所有正经的元素当具有某种属性的时候，会激发隐藏技能。玄而又玄。 你不知道的CSS List1、层叠顺序（stacking level）与堆栈上下文（stacking context）知多少？2、从倒影说起，谈谈 CSS 继承 inherit3、IFC、BFC、GFC 与 FFC 知多少4、结构性伪类选择器5、引人瞩目的 CSS 变量（Variable）6、CSS命名方式是否有必要规范7、reset.css 知多少 8、你该知道的字体 font-family9、再探究字体的渲染规则及 fallback 机制10、使用 position:sticky 实现粘性布局11、深入探讨 CSS 特性检测 @supports 与 Modernizr12、提高 CSS 动画性能的正确姿势 | 盒子端 CSS 动画性能提升研究13、纯 CSS 方式实现 CSS 动画的暂停与播放14、谈谈 CSS 关键字 initial、inherit 和 unset15、使用 display:flex 实现瀑布流布局16、vh、vw、vmin、vmax 知多少17、奇妙的-webkit-background-clip: text18、神奇的 conic-gradient 圆锥渐变19、不可思议的混合模式 mix-blend-mode 20、不可思议的混合模式 background-blend-mode21、奇妙的 CSS shapes（CSS图形）22、纯 CSS 实现波浪效果!23、CSS 新特性contain，控制页面的重绘与重排24、fixed 定位失效 || 不受控制的 position:fixed25、你所不知道的 CSS 动画技巧与细节26、你所不知道的 CSS 滤镜技巧与细节27、text-fill-color 与 color 的异同28、两行 CSS 代码实现图片任意颜色赋色技术29、聊聊逐帧动画与过渡动画，耗性能样式的取舍🤡 跟浏览器谈个恋爱？没有跟它（IE）有过感情纠纷，但是听朋友是一个很差的差劲的对象。建议最好了解一下她的坏脾气，免得真正遇到的时候无法面对。 最喜欢金丝雀（Chrome）,正牌女友的最佳人选。你想要的各种技能都有，会把你照顾的舒舒服服的。拥有它，你的天空都会是蓝色的。 还有小🦊（Firefox）,会中文不得不说很照顾一部分人。当作备胎也是不错的。 至于其他的，搜歌，360，小白，等等其他的小家伙。这些都是chrome的子子孙孙，很是年幼。就不考虑了。 不过听说遨游不错，跟Chrome的父辈是一个辈分的。 了解一些历史不足为奇。 但是你知道他们怎么帮你展示世界的吗？ 【译】浏览器渲染：repaint,reflow&#x2F;relayout,restyle 相信我，你会受益匪浅的。 👻👻我总结👻👻 W3c出的标准一定要看，这样才能当最牛逼的切图仔，否则直接让设计师切图咯？ 不能抛却历史，拥抱未来。没有历史的故事，不算完整的故事。 新知识分两种，一种是全新的知识，一种是存在但是不了解的知识。 切图不仅仅是div+css，还有你的小情人。 学会与设计妹子聊人生设计，否则怎么99%的还原设计稿呢？","tags":[{"name":"重构","slug":"重构","permalink":"http://example.com/tags/%E9%87%8D%E6%9E%84/"},{"name":"切图仔","slug":"切图仔","permalink":"http://example.com/tags/%E5%88%87%E5%9B%BE%E4%BB%94/"}]},{"title":"Nginx简明配置","date":"2017-10-21T14:12:42.000Z","path":"2017/10/21/Nginx简明配置/","text":"内容简介 需要nginx的场景 简单介绍下nginx用法 配置一个简单的web静态资源服务器 场景 开发的时候需要代理第三方的服务去调试（联调） SPA都是通过接口去挂载应用，当我们开发完成后单独部署一次模拟测试环境 查看一些静态资源请求，模拟线上真实环境的压缩，请求，响应 Nginx 的用法Nginx反向代理发布多个域名80端口的WEB服务 1234567891011121314151617181920server &#123; listen 80; server_name www.aaa.com; location / &#123; proxy_pass http://127.0.0.1:3000; &#125; location /static/ &#123; proxy_pass http://127.0.0.1:3000/static/; &#125;&#125;server &#123; listen 80; server_name www.bbb.com; location / &#123; proxy_pass http://127.0.0.1:4000; &#125; location /static/ &#123; proxy_pass http://127.0.0.1:4000/static/; &#125; &#125; 配置了两个80的端口服务，绑定host之后，访问www.aaa.com相当于访问3000的本地服务，静态资源也是3000的资源，访问www.bbb.com相当于访问4000的本地服务，静态资源也是4000的资源 Nginx绑定域名访问 12345678server &#123; listen 10086; server_name www.aaa.com; location / &#123; root &quot;F:/filepath&quot;; index index.html; &#125;&#125; 访问IP:10086就会直接去访问项目了 配置一个简单的web服务器 因为我们是web开发者，所有写出来的代码都会在web放服务器上运行 比如我们做了一个官网，想在本地部署一套环境给产品，设计观看预览 12345678910111213141516171819server &#123; listen 80; # 对外开放的端口号 server_name kunyi.stnts.com; location / &#123; # 通过域名或者端口号直接进来的一个目录 root &quot;F:/ST/project/kunyi/&quot;; # 启用目录浏览 ，这个看需求（如果只想对外暴露index就不要用） autoindex on; &#125; # 配置静态资源的缓存时间 location ~ .*\\.(js|css|jpg)?$ &#123; expires 30d; &#125;&#125; 我本地有一套开发环境，进入联调阶段了，现在我想代理到后端去做调试,当然我们也可以使用webpack dev去做代理调试，一般也是建议这么做，但是当我频繁切换代理服务，每次都去重启服务显然就不是很划算了。这个时候我们可以使用nginx代理去做了 1234567891011server &#123; listen 801; location /&#123; proxy_pass http:# localhost:3001; &#125; location ^~ /api/&#123; proxy_pass http://192.168.35.153:8081; &#125;&#125; 如果从ngixn做了代理的话，那么webpack dev的代理就不会起作用了 当我开发完成，想在本机或者是虚拟机上部署一个web服务 123456789101112131415161718192021222324server &#123; listen 1012; server_name aa.com; # 指定项目root目录 location /&#123; root &quot;F:/filepath/&quot;; index index.html; &#125; # 指定静态资源目录 location /front/ &#123; alias &quot;F:/filepath/&quot;; &#125; # 反向代理配置 location ^~ /api/&#123; proxy_pass http://domain.com; &#125; # 反向代理配置 location ^~ /service/&#123; proxy_pass http://domain.com; &#125;&#125;","tags":[{"name":"前端环境","slug":"前端环境","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83/"},{"name":"Ngixn","slug":"Ngixn","permalink":"http://example.com/tags/Ngixn/"}]},{"title":"MOCK平台分析报告","date":"2017-10-21T13:38:53.000Z","path":"2017/10/21/MOCK平台分析报告/","text":"背景前后端分离的工作模式下面，API交互文档亦然成为前后端沟通最佳介质。依赖文档，简化沟通，提高写作效率。 文档如何形成API文档应有前后端共同约定，商议。实际开发中API文档由后端同学维护，因为前端是API的消费者。提供文档的方式有很多种： Txt，Markdown , Word原始，文档作者手动录入，接口变动需要以来文档作者实时更新，易读性取决于作者. 文档没有集中管理方式 文档平台（公司内部文档平台）文档集中管理，手动录入，同步不够简化，文档结构有同意约束 Swagger 文档文档自动生成，前期会增加额外的后端同学开发工作 ，文档详细。接口变动实时同步 前端如何消费API文档API文档规定了API URL，API RESPONSE，API RESQUEST，前端同学按照文档格式编写交互代码，有几种方式 手写模拟JSON ，直接请求 手写模拟JSON ，使用 NGINX 或者 NODE 转发 使用构建工具（FIS3，Webpack）内置的Node服务转发JSON，或者是本地启动Node sever MOCK SERVER 平台 本地直接代理到后端服务（这种场景仅限于后端工作前置前端许多） 总体来说，前端消费API文档不外乎几点 手写JSON &amp;&amp; 自动生产JSON 本地转发 &amp;&amp; 统一平台管理 AMPApi Manage Platform 是2016-10-10部署在公司内网的一个简易MOCK SERVER 服务。提供的功能有： 注册，登陆，项目权限控制 手动录入API，生成MOCK地址 录入Swagger json , 自动生成API文档与MOCK 服务 简单的接口检测工具 Easy-MockEasy mock 是2017-09-10部署在公司内网的一个简易MOCK SERVER 服务。提供的功能有： 注册，登陆，项目权限控制 手动录入API，生成MOCK地址 录入Swagger json , 自动生成API文档与MOCK 服务 项目复制与接口复制 可视化接口数据编辑 打包下载全部接口 mockjs-支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等 mockjs-支持扩展更多数据类型，支持自定义函数和正则 支持响应式数据（自定义JS函数） 支持数据代理（这个功能暂时是鸡肋） 支持JSONP 支持restful接口 结合（easy mock cli)生成请求函数，在我们react体系中应用不大，可以改造 EASY-MOCK 亮点 需要优化与BUG 支持Swagger，自动与手动编辑接口 swagger仅支持标准openapi范式，公司内部swagger多数有自定义格式，swagger支持不是很好 支持Mockjs与响应式数据 接口代理功能属于鸡肋 可视化数据编辑 快捷键容易造成误操作（已经提issues） 接口复制，项目克隆 官方维护貌似挺慢的 项目接口打包下载 暂未支持版本管理与DIFF Easy-mock 解决了什么 项目统一的文档管理与接口服务 前端MOCK服务，后端录入文档，前端可以直接使用，不用本地增加任何开发设施（转发服务，本地JSON生成） 原有流程：API文档（找个位置放着） =&gt; 前端手动翻译成MOCK JSON =&gt; 设置本地代理或者转发 =&gt; 交互开发 改后流程：EASY MOCK API文档 &#x3D;&gt; 交互开发 丰富了前端MOCK方式与更多功能性 总结与建议 前后端开发文档应当集中管理，而不是根据项目走 前后端API文档应该由前后端共同约定 尽量统一公司内部文档格式，如果不是swagger的话，可以共同约定一种格式 如果项目的文档提供方式是以手动书写（MD , TXT , DOC）提供的话建议直接迁移到 接口平台（Easy-mock），方便管理与记录 ​ 其他(开源mock平台)AMP@小爝团队开源产品与Easy-MockBy芋头团队开源产品 ​","tags":[{"name":"平台","slug":"平台","permalink":"http://example.com/tags/%E5%B9%B3%E5%8F%B0/"},{"name":"前后端开发","slug":"前后端开发","permalink":"http://example.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}]},{"title":"JSX中使用SVG","date":"2017-10-21T13:36:23.000Z","path":"2017/10/21/JSX中使用SVG/","text":"webpack 增加 svg-inline-loader 123456npm i svg-inline-loader --save-dev&#123;test: /\\.svg$/,loader: &#x27;svg-inline-loader&#x27;&#125; JSX使用 svg 12const newad = require(&#x27;../../public/newad.svg&#x27;)&lt;svg style=&#123;&#123;fill: &quot;#fff&quot;&#125;&#125; dangerouslySetInnerHTML=&#123;&#123;__html: newad &#125;&#125; /&gt;","tags":[{"name":"开发框架","slug":"开发框架","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"},{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"Cenos前端环境搭建.md","date":"2017-10-21T13:30:43.000Z","path":"2017/10/21/Cenos前端环境搭建/","text":"查询机器版本，位数12uname -a **查询所有信息cat /etc/redhat-releae **查询版本 更新kernel 安装 ELRepo到centos系统中 1rpm -Uvh http://www.elrepo.org/elrepo-release-6-6.el6.elrepo.noarch.rpm 查询列出目前的内核版本 1yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; list available 内核版本更新 12yum --enablerepo=elrepo-kernel install kernel-ml 更换Repo 首先备份&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载对应版本repo文件, 放入&#x2F;etc&#x2F;yum.repos.d 1234curl http://mirrors.163.com/.help/CentOS6-Base-163.repo -o CentOS6-Base-163.repoyum clean all **清除缓存yum makecache **生成缓存yum repolist **查看生效repolist 安装NVM​ nvm(v0.33.0) 是 Nodejs 版本管理工具。nvm 是安装node最简单的方式。 ​ 使用Git方式安装，有助于自定义nvm安装目录。一般安装在 /usr/local 全局目录。 ​ 需要使用（v0.33.0）版本，最新（v0.33.2）实测有问题。 安装 Ci Runner 安装 gitlab-ci-multi-runner 配置Specific Runner，Config Function 其他 快速搭建 Node.js 开发环境以及加速 npm ​","tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"前端环境","slug":"前端环境","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E7%8E%AF%E5%A2%83/"}]},{"title":"Mock这件小事的思考","date":"2017-04-25T12:28:25.000Z","path":"2017/04/25/mock/","text":"前后端API沟通方式标准化 由后端提供统一格式的API描述文档，公司应用比较多的有Swagger、APIDoc.建议统一成Swagger Json. AMP需要做什么？ 支持导入类似 Swagger Json的API描述文件，并且生成对应的Mock接口数据 支持权限的划分，多人编辑 提供Mock.js模版数据功能 解决的问题 统一前后端沟通标准（API描述文档） 支持自动生成 Mock 数据 争议问题 AMP平台上的数据是由后端开发人员提供的文件生成，这个时候前端的开发必须依赖后端开发人员提供文档的质量，这样子的话会影响到前端的开发。 一旦描述文档生成mock，前端mock是必须要要与平台关联起来。因为mock平台不支持外网访问，如果想在家去做开发将会比较困难。 假设现在文档已经形成，但是后端在开发的时候发现某些API设计有些许问题，然后直接在代码修改了，但是忘记更新文档，那么这个时候我的测试环境等 CI就无法完成，并且又可能前端为了找出这个差异需要花一定的时间去DEBUG。这里咱们就要说说后端开发人员的文档形成模式了，咱们暂且说Swagger。它提供了两种文档编辑模式： 侵入式 优点：代码修改，文档自动变化。解决了上述问题 缺点：侵入业务逻辑，上线可以去掉，但是修改一个接口会比较繁琐，增加开发任务 编辑式 优点：修改文档迅速 缺点：手动维护文档，会出现上述错误 思考的解决方案 针对问题2，我们把AMP上的接口当作一个管理平台，然后本地写个脚本或者是工具，把接口生成本地文件，然后 DEV rewrite 到本地文件。同时还可以满足统一个接口的不同开发者差异化，如果AMP提供了MOCKJS的功能的话这个优势可以取消。 针对问题3，提供一层数据检查机制，当后端完成一个测试环境的接口时自动去跑一边测试接口与描述文档生成的接口的差异化检查。如果有差异自动提醒","tags":[{"name":"mock","slug":"mock","permalink":"http://example.com/tags/mock/"}]},{"title":"JS基础之IIFE","date":"2017-03-09T15:26:32.000Z","path":"2017/03/09/JS高级之IIFE/","text":"什么是自执行（Immediately-Invoked Function Expression）？ 在JavaScript里，任何function在执行的时候都会创建一个执行上下文，因为为function声明的变量和function有可能只在该function内部，这个上下文，在调用function的时候，提供了一种简单的方式来创建自由变量或私有子function。 1234567891011121314151617181920212223// 由于该function里返回了另外一个function，其中这个function可以访问自由变量i// 所有说，这个内部的function实际上是有权限可以调用内部的对象。function makeCounter() &#123; // 只能在makeCounter内部访问i var i = 0; return function () &#123; console.log(++i); &#125;;&#125;// 注意，counter和counter2是不同的实例，分别有自己范围内的i。var counter = makeCounter();counter(); // logs: 1counter(); // logs: 2var counter2 = makeCounter();counter2(); // logs: 1counter2(); // logs: 2alert(i); // 引用错误：i没有defind（因为i是存在于makeCounter内部）。 很多情况下，我们不需要makeCounter多个实例，甚至某些case下，我们也不需要显示的返回值，OK，往下看。 问题的核心当你声明类似function foo(){}或var foo &#x3D; function(){}函数的时候，通过在后面加个括弧就可以实现自执行，例如foo()，看代码： 123456789// 因为想下面第一个声明的function可以在后面加一个括弧()就可以自己执行了，比如foo()，// 因为foo仅仅是function() &#123; /* code */ &#125;这个表达式的一个引用var foo = function()&#123; /* code */ &#125;// ...是不是意味着后面加个括弧都可以自动执行？function()&#123; /* code */ &#125;(); // SyntaxError: Unexpected token (// 上述代码，如果甚至运行，第2个代码会出错，因为在解析器解析全局的function或者function内部function关键字的时候，默认是认为function声明，而不是function表达式，如果你不显示告诉编译器，它默认会声明成一个缺少名字的function，并且抛出一个语法错误信息，因为function声明需要一个名字。 旁白：函数(function)，括弧(paren)，语法错误(SyntaxError)有趣的是，即便你为上面那个错误的代码加上一个名字，他也会提示语法错误，只不过和上面的原因不一样。在一个表达式后面加上括号()，该表达式会立即执行，但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。 12345678910111213// 下面这个function在语法上是没问题的，但是依然只是一个语句// 加上括号()以后依然会报错，因为分组操作符需要包含表达式function foo()&#123; /* code */ &#125;(); // SyntaxError: Unexpected token )// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出// 但是foo函数依然不会执行function foo()&#123; /* code */ &#125;( 1 );// 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式：function foo()&#123; /* code */ &#125;( 1 ); 自执行函数表达式 要解决上述问题，非常简单，我们只需要用大括弧将代码的代码全部括住就行了，因为JavaScript里括弧()里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明。 1234567891011121314151617181920212223242526// 下面2个括弧()都会立即执行(function () &#123; /* code */ &#125; ()); // 推荐使用这个(function () &#123; /* code */ &#125;)(); // 但是这个也是可以用的// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了// 不过，请注意下一章节的内容解释var i = function () &#123; return 10; &#125; ();true &amp;&amp; function () &#123; /* code */ &#125; ();0, function () &#123; /* code */ &#125; ();// 如果你不在意返回值，或者不怕难以阅读// 你甚至可以在function前面加一元操作符号!function () &#123; /* code */ &#125; ();~function () &#123; /* code */ &#125; ();-function () &#123; /* code */ &#125; ();+function () &#123; /* code */ &#125; ();// 还有一个情况，使用new关键字,也可以用，但我不确定它的效率// http://twitter.com/kuvos/status/18209252090847232new function () &#123; /* code */ &#125;new function () &#123; /* code */ &#125; () // 如果需要传递参数，只需要加上括弧() 上面所说的括弧是消除歧义的，其实压根就没必要，因为括弧本来内部本来期望的就是函数表达式，但是我们依然用它，主要是为了方便开发人员阅读，当你让这些已经自动执行的表达式赋值给一个变量的时候，我们看到开头有括弧(，很快就能明白，而不需要将代码拉到最后看看到底有没有加括弧。 credit 立即调用的函数表达式 立即调用的函数表达式存在的意义 IFEE","tags":[{"name":"JS高级","slug":"JS高级","permalink":"http://example.com/tags/JS%E9%AB%98%E7%BA%A7/"},{"name":"前端进阶","slug":"前端进阶","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"}]},{"title":"JS基础之圆括号","date":"2017-03-09T15:14:34.000Z","path":"2017/03/09/JS基础之圆括号/","text":"运算符 圆括号运算符( ) 用来控制表达式中的运算优先级. 12345678910111213141516var a = 1;var b = 2;var c = 3;// default precedencea + b * c // 7// evaluated by default like thisa + (b * c) // 7// now overriding precedence// addition before multiplication (a + b) * c // 9// which is equivalent toa * c + b * c // 9 分组运算符 Return the result of evaluating Expression. This may be of type Reference. 返回评估括号中的表达式的结果。结果可能是Reference类型。 抛开像Reference类型这种词汇，这里的一个关键词应当是“ 评估 ”（对evaluate的翻译一直把握不好，姑且这么叫吧），但是关于分组运算符，又有一个很重要的下文： This algorithm does not apply GetValue to the result of evaluating Expression. 这个算法不会对估算的结果使用GetValue。 有很多专用的名词，看起来确实复杂，简而言之，使用括号运算符本身不会让括号中的代码立即执行，只有当括号包含的这个“分组”参与其他运算时，才会执行。因此，(function(){})()这个语句，其实是首先用分组运算符评估了一个函数表达式，随后参与“函数调用”。而(function(){}())这个语句，则是用分组运算符评估了一个函数调用，随后由于语句的结束而被执行。从语句上来说有细微的差距，当然就结果而言是一样的， credit 分组运算符","tags":[{"name":"前端进阶","slug":"前端进阶","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"},{"name":"JS基础","slug":"JS基础","permalink":"http://example.com/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"前端的持续集成与部署","date":"2017-03-06T14:12:42.000Z","path":"2017/03/06/前端的持续集成与部署/","text":"开发流程图 开发CI流程 提测CI流程 备注（xx-Note）： SCP-Note 使用shell命令上传文件，速度较快 前提是需要配置两台（CI runner &amp;&amp; Test Machine）机器SSH认证。 GIT-Note 需要一个 Builder Repository（可以新建，可以使后端项目存放前端代码的目录或者分支） 前提是需要配置两台（CI runner &amp;&amp; Test Machine）机器相对于这个Builder Repository的SSH权限。速度较慢，需要Runner先push,然后Tester去pull. GIT 与 SCP 的区别？ SCP便于频繁发布代码，但是Builder仓库没有记录。GIT每一次提交都会产生Builder的提交，但是速度慢。 为什么会有Builder的仓库？ 公司内部的prp系统暂时只支持版本库的代码发布。 CI自动提交GIT会不会出现不可控因素？ 不会，因为每次一提交失败会导致CI的TASK出错，然后会有邮件提示。并且可以全部采用GIT的方式更新代码，这样的话测试与上线使用的代码是一样的，如果测试通过，那么上线代码一定是正确的。 CI需要什么工具 gitlab-ci ， ssh , 测试服务器","tags":[{"name":"开发流程","slug":"开发流程","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"name":"持续部署","slug":"持续部署","permalink":"http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/"}]},{"title":"前端项目为什么需要CI？","date":"2017-02-08T15:00:09.000Z","path":"2017/02/08/Gitlab的CI起源/","text":"Gitlab-Ci 的过程（采取有力措施，防止人为失误）进来热议的“工匠精神”，实质上是关注人力资源因素对产品及质量的影响。人是质量工作中最活跃，最重要的因素。也是管理难度最大的。在质量管理体系运行中，从流程到标准，都是需要人来做对。防止人为差错已成为质量保证的当务之急。那些依赖多人对过程，应特别关注是否有防错措施。 人为错误有两种： 有意识制造差错 无意识制造差错 人为错误剖析： 人都不想出错 失败又不是什么关荣的事情，有时候还会遭到周围人责备，所以谁也不回故意出错。 BUT 事实上如果一度认为【认为错误是没有办法的】，敷衍了事地对应，错误是不回减少的 产生错误的背景： 不知道（不明白 ● 没有听 ● 忘记了） 不知道要确认，没有仔细看文档 不会做（知道，但是能力不足） 猜着去做 忽略危机（习惯 ● 本能走捷径） |- 一直以来都是ok的，所以认为不检查没有问题 |- 随意地判断以为这样的就没有问题了 |- 过于相信自己 错觉（误解，深信） 紧急时慌张，疲劳，注意力散漫（慌张更容易失误） 我们需要有效的方法，工具，流程来防止人为失误前端代码开发发布我们一直遵循着这个步骤： 我们走的是邮件流程，所有的人为操作都会由邮件记录，这是一个公司基本流程。 But 上面的开发，测试，发布流程是否满足需要？ 或者 上面的流程是否容易受到人力因素的巨大影响? 环节 因素 结果 开发阶段 误解需求，某些需求忘记了 测试或者上线时才发现少了功能，或者功能不对 发布阶段 人为发错版本号 线上功能受到影响 开发阶段，某些需求没有具体原型，或者口头叙述没有相关文档，并且开发者未记录，那么很容易产生测试或者上线的出现， Oh , shit !还有这么个功能，看来每次需求会议需要记录了。或者是对需求的时候仔细确认。 开发的时候我们有可能处于这个流程 这个时候我需要上B任务： 我应该发布（2300–2310），跳过了（2299-2300）属于跳版本发布 正常任务流中避讳跳版本，这样会使整个版本流显得混乱。 并且可能遗漏发布某些文件，这也属于常规人为失误。 或者是我直接忽略影响，直接发布（2999-2310） 这样就会把错误的A任务的文件给发布线上，带来的影响也是最大的。 或者是我直接发布最新版本，直接发布（2999-2312） 这个时候可能A任务还未测试完成，发布线上会有风险。 上面的过程很容易产生人为失误。 我们需要解决的事情 基于git分支的commit的发布 Git工作流 自动构建部署 持续集成过程过程（Gitlab-Ci） 配置gitlab-runner Gitlab 8.0 给我们提供了ci的工具，使用简单的yaml配置就可以执行我们的构建命令，并且保存每次的构建结果。那么runner就是给我们跑命令的机器环境（可以是虚拟机，docker容器…..） GitLab-CI与GitLab-Runner 项目生产环境依赖锁定 为什么要锁定当前目录生产依赖(node_modules),因为我要确定runner的环境要与开发一致，这样构建的结果才能与开发一致。这是我需要解决的事情，但是还有一个原因希望我的项目环境依赖是固定的，方便迁移开发，不受外部原因的影响。 从 left-pad 事件我们可以学到什么? 配置gitlab-runner runner 一般需要运维去配置，如果懂一些简单的linux系统的话。自己也是可以配置一个项目的runner。讲一下配置的项目runner中遇到的一些事情： 先要在Specific Runner(CentOs.6.8)机器上安装gitlab-ci-multi-runner curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bashyum install gitlab-ci-multi-runner 在Gitlab上注册你的runner机器 gitlab-ci-multi-runner register注册的gitlab-runner的机器默认是以gitlab-runner身份默认登录runner机器，所以要确保相对应的用户有node,npm相关软件执行权限 锁定项目依赖资源表 现有的前端大而全，都会依赖一些构建工具。前端研发部采用的是fis流程，整套流程实验证明是很有价值的。但是会有一部分瑕疵：无人维护、插件质量，Bug数总量，等等。但我们现有的fis流程跑的很溜的时候， 迁移到其他开发环境是否同样顺呢？ 不会的 ，不同的环境受到网络，node，npm版本影响，都会出现各种问题，最大的问题是可能出现，npm中的软件包会经常改变依赖版本，这样的话就需要我们锁定当前健康的构建依赖。 解决方案：npm shrinkwrap锁定当前的依赖关系npm shrinkpack下载当前依赖的node_module/*.tar包npm-shrinkwrap.json&amp;npm_shrinkwrap/提交至gitlabgit co &amp; npm i这个时候你会发现下载数据非常快，因为直接从tar包中安装解压依赖。 从 left-pad 事件我们可以学到什么? 文档历史 write by Alex Lin at 2017-01-12","tags":[{"name":"开发流程","slug":"开发流程","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"name":"持续部署","slug":"持续部署","permalink":"http://example.com/tags/%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/"}]}]