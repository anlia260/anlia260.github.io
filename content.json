[{"title":"Hello World","date":"2017-08-09T02:54:04.000Z","path":"2017/08/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Mock这件小事的思考","date":"2017-04-25T12:28:25.000Z","path":"2017/04/25/mock/","text":"前后端API沟通方式标准化 由后端提供统一格式的API描述文档，公司应用比较多的有Swagger、APIDoc.建议统一成Swagger Json. AMP需要做什么？ 支持导入类似 Swagger Json的API描述文件，并且生成对应的Mock接口数据 支持权限的划分，多人编辑 提供Mock.js模版数据功能 解决的问题 统一前后端沟通标准（API描述文档） 支持自动生成 Mock 数据 争议问题 AMP平台上的数据是由后端开发人员提供的文件生成，这个时候前端的开发必须依赖后端开发人员提供文档的质量，这样子的话会影响到前端的开发。 一旦描述文档生成mock，前端mock是必须要要与平台关联起来。因为mock平台不支持外网访问，如果想在家去做开发将会比较困难。 假设现在文档已经形成，但是后端在开发的时候发现某些API设计有些许问题，然后直接在代码修改了，但是忘记更新文档，那么这个时候我的测试环境等 CI就无法完成，并且又可能前端为了找出这个差异需要花一定的时间去DEBUG。这里咱们就要说说后端开发人员的文档形成模式了，咱们暂且说Swagger。它提供了两种文档编辑模式： 侵入式 优点：代码修改，文档自动变化。解决了上述问题 缺点：侵入业务逻辑，上线可以去掉，但是修改一个接口会比较繁琐，增加开发任务 编辑式 优点：修改文档迅速 缺点：手动维护文档，会出现上述错误 思考的解决方案 针对问题2，我们把AMP上的接口当作一个管理平台，然后本地写个脚本或者是工具，把接口生成本地文件，然后 DEV rewrite 到本地文件。同时还可以满足统一个接口的不同开发者差异化，如果AMP提供了MOCKJS的功能的话这个优势可以取消。 针对问题3，提供一层数据检查机制，当后端完成一个测试环境的接口时自动去跑一边测试接口与描述文档生成的接口的差异化检查。如果有差异自动提醒","tags":[{"name":"mock","slug":"mock","permalink":"www.fudoor.net/tags/mock/"}]},{"title":"JS基础之IIFE","date":"2017-03-09T15:26:32.000Z","path":"2017/03/09/JS高级之IIFE/","text":"什么是自执行（Immediately-Invoked Function Expression）？ 在JavaScript里，任何function在执行的时候都会创建一个执行上下文，因为为function声明的变量和function有可能只在该function内部，这个上下文，在调用function的时候，提供了一种简单的方式来创建自由变量或私有子function。 1234567891011121314151617181920212223// 由于该function里返回了另外一个function，其中这个function可以访问自由变量i// 所有说，这个内部的function实际上是有权限可以调用内部的对象。function makeCounter() &#123; // 只能在makeCounter内部访问i var i = 0; return function () &#123; console.log(++i); &#125;;&#125;// 注意，counter和counter2是不同的实例，分别有自己范围内的i。var counter = makeCounter();counter(); // logs: 1counter(); // logs: 2var counter2 = makeCounter();counter2(); // logs: 1counter2(); // logs: 2alert(i); // 引用错误：i没有defind（因为i是存在于makeCounter内部）。 很多情况下，我们不需要makeCounter多个实例，甚至某些case下，我们也不需要显示的返回值，OK，往下看。 问题的核心当你声明类似function foo(){}或var foo = function(){}函数的时候，通过在后面加个括弧就可以实现自执行，例如foo()，看代码： 123456789// 因为想下面第一个声明的function可以在后面加一个括弧()就可以自己执行了，比如foo()，// 因为foo仅仅是function() &#123; /* code */ &#125;这个表达式的一个引用var foo = function()&#123; /* code */ &#125;// ...是不是意味着后面加个括弧都可以自动执行？function()&#123; /* code */ &#125;(); // SyntaxError: Unexpected token (// 上述代码，如果甚至运行，第2个代码会出错，因为在解析器解析全局的function或者function内部function关键字的时候，默认是认为function声明，而不是function表达式，如果你不显示告诉编译器，它默认会声明成一个缺少名字的function，并且抛出一个语法错误信息，因为function声明需要一个名字。 旁白：函数(function)，括弧(paren)，语法错误(SyntaxError)有趣的是，即便你为上面那个错误的代码加上一个名字，他也会提示语法错误，只不过和上面的原因不一样。在一个表达式后面加上括号()，该表达式会立即执行，但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。 12345678910111213// 下面这个function在语法上是没问题的，但是依然只是一个语句// 加上括号()以后依然会报错，因为分组操作符需要包含表达式function foo()&#123; /* code */ &#125;(); // SyntaxError: Unexpected token )// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出// 但是foo函数依然不会执行function foo()&#123; /* code */ &#125;( 1 );// 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式：function foo()&#123; /* code */ &#125;( 1 ); 自执行函数表达式 要解决上述问题，非常简单，我们只需要用大括弧将代码的代码全部括住就行了，因为JavaScript里括弧()里面不能包含语句，所以在这一点上，解析器在解析function关键字的时候，会将相应的代码解析成function表达式，而不是function声明。 1234567891011121314151617181920212223242526// 下面2个括弧()都会立即执行(function () &#123; /* code */ &#125; ()); // 推荐使用这个(function () &#123; /* code */ &#125;)(); // 但是这个也是可以用的// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了// 不过，请注意下一章节的内容解释var i = function () &#123; return 10; &#125; ();true &amp;&amp; function () &#123; /* code */ &#125; ();0, function () &#123; /* code */ &#125; ();// 如果你不在意返回值，或者不怕难以阅读// 你甚至可以在function前面加一元操作符号!function () &#123; /* code */ &#125; ();~function () &#123; /* code */ &#125; ();-function () &#123; /* code */ &#125; ();+function () &#123; /* code */ &#125; ();// 还有一个情况，使用new关键字,也可以用，但我不确定它的效率// http://twitter.com/kuvos/status/18209252090847232new function () &#123; /* code */ &#125;new function () &#123; /* code */ &#125; () // 如果需要传递参数，只需要加上括弧() 上面所说的括弧是消除歧义的，其实压根就没必要，因为括弧本来内部本来期望的就是函数表达式，但是我们依然用它，主要是为了方便开发人员阅读，当你让这些已经自动执行的表达式赋值给一个变量的时候，我们看到开头有括弧(，很快就能明白，而不需要将代码拉到最后看看到底有没有加括弧。 credit 立即调用的函数表达式 立即调用的函数表达式存在的意义 IFEE","tags":[{"name":"前端进阶","slug":"前端进阶","permalink":"www.fudoor.net/tags/前端进阶/"},{"name":"JS高级","slug":"JS高级","permalink":"www.fudoor.net/tags/JS高级/"}]},{"title":"JS基础之圆括号","date":"2017-03-09T15:14:34.000Z","path":"2017/03/09/JS基础之圆括号/","text":"运算符 圆括号运算符( ) 用来控制表达式中的运算优先级. 123456789101112131415var a = 1;var b = 2;var c = 3;// default precedencea + b * c // 7// evaluated by default like thisa + (b * c) // 7// now overriding precedence// addition before multiplication (a + b) * c // 9// which is equivalent toa * c + b * c // 9 分组运算符 Return the result of evaluating Expression. This may be of type Reference. 返回评估括号中的表达式的结果。结果可能是Reference类型。 抛开像Reference类型这种词汇，这里的一个关键词应当是“ 评估 ”（对evaluate的翻译一直把握不好，姑且这么叫吧），但是关于分组运算符，又有一个很重要的下文： This algorithm does not apply GetValue to the result of evaluating Expression. 这个算法不会对估算的结果使用GetValue。 有很多专用的名词，看起来确实复杂，简而言之，使用括号运算符本身不会让括号中的代码立即执行，只有当括号包含的这个“分组”参与其他运算时，才会执行。因此，(function(){})()这个语句，其实是首先用分组运算符评估了一个函数表达式，随后参与“函数调用”。而(function(){}())这个语句，则是用分组运算符评估了一个函数调用，随后由于语句的结束而被执行。从语句上来说有细微的差距，当然就结果而言是一样的， credit 分组运算符","tags":[{"name":"JS基础","slug":"JS基础","permalink":"www.fudoor.net/tags/JS基础/"},{"name":"前端进阶","slug":"前端进阶","permalink":"www.fudoor.net/tags/前端进阶/"}]},{"title":"前端的持续集成与部署","date":"2017-03-06T14:12:42.000Z","path":"2017/03/06/前端的持续集成与部署/","text":"开发流程图 开发CI流程 提测CI流程 备注（xx-Note）： SCP-Note 使用shell命令上传文件，速度较快 前提是需要配置两台（CI runner &amp;&amp; Test Machine）机器SSH认证。 GIT-Note 需要一个 Builder Repository（可以新建，可以使后端项目存放前端代码的目录或者分支） 前提是需要配置两台（CI runner &amp;&amp; Test Machine）机器相对于这个Builder Repository的SSH权限。速度较慢，需要Runner先push,然后Tester去pull. GIT 与 SCP 的区别？ SCP便于频繁发布代码，但是Builder仓库没有记录。GIT每一次提交都会产生Builder的提交，但是速度慢。 为什么会有Builder的仓库？ 公司内部的prp系统暂时只支持版本库的代码发布。 CI自动提交GIT会不会出现不可控因素？ 不会，因为每次一提交失败会导致CI的TASK出错，然后会有邮件提示。并且可以全部采用GIT的方式更新代码，这样的话测试与上线使用的代码是一样的，如果测试通过，那么上线代码一定是正确的。 CI需要什么工具 gitlab-ci ， ssh , 测试服务器","tags":[{"name":"开发流程","slug":"开发流程","permalink":"www.fudoor.net/tags/开发流程/"},{"name":"持续部署","slug":"持续部署","permalink":"www.fudoor.net/tags/持续部署/"}]},{"title":"前端项目为什么需要CI？","date":"2017-02-08T15:00:09.000Z","path":"2017/02/08/Gitlab的CI起源/","text":"Gitlab-Ci 的过程（采取有力措施，防止人为失误）进来热议的“工匠精神”，实质上是关注人力资源因素对产品及质量的影响。人是质量工作中最活跃，最重要的因素。也是管理难度最大的。在质量管理体系运行中，从流程到标准，都是需要人来做对。防止人为差错已成为质量保证的当务之急。那些依赖多人对过程，应特别关注是否有防错措施。 人为错误有两种： 有意识制造差错 无意识制造差错 人为错误剖析： 人都不想出错 失败又不是什么关荣的事情，有时候还会遭到周围人责备，所以谁也不回故意出错。 BUT 事实上如果一度认为【认为错误是没有办法的】，敷衍了事地对应，错误是不回减少的 产生错误的背景： 不知道（不明白 ● 没有听 ● 忘记了） 不知道要确认，没有仔细看文档 不会做（知道，但是能力不足） 猜着去做 忽略危机（习惯 ● 本能走捷径） |- 一直以来都是ok的，所以认为不检查没有问题 |- 随意地判断以为这样的就没有问题了 |- 过于相信自己 错觉（误解，深信） 紧急时慌张，疲劳，注意力散漫（慌张更容易失误） 我们需要有效的方法，工具，流程来防止人为失误前端代码开发发布我们一直遵循着这个步骤： 我们走的是邮件流程，所有的人为操作都会由邮件记录，这是一个公司基本流程。 But 上面的开发，测试，发布流程是否满足需要？ 或者 上面的流程是否容易受到人力因素的巨大影响? 环节 因素 结果 开发阶段 误解需求，某些需求忘记了 测试或者上线时才发现少了功能，或者功能不对 发布阶段 人为发错版本号 线上功能受到影响 开发阶段，某些需求没有具体原型，或者口头叙述没有相关文档，并且开发者未记录，那么很容易产生测试或者上线的出现， Oh , shit !还有这么个功能，看来每次需求会议需要记录了。或者是对需求的时候仔细确认。 开发的时候我们有可能处于这个流程 这个时候我需要上B任务： 我应该发布（2300–2310），跳过了（2299-2300）属于跳版本发布 正常任务流中避讳跳版本，这样会使整个版本流显得混乱。 并且可能遗漏发布某些文件，这也属于常规人为失误。 或者是我直接忽略影响，直接发布（2999-2310） 这样就会把错误的A任务的文件给发布线上，带来的影响也是最大的。 或者是我直接发布最新版本，直接发布（2999-2312） 这个时候可能A任务还未测试完成，发布线上会有风险。 上面的过程很容易产生人为失误。 我们需要解决的事情 基于git分支的commit的发布 Git工作流 自动构建部署 持续集成过程过程（Gitlab-Ci） 配置gitlab-runner Gitlab 8.0 给我们提供了ci的工具，使用简单的yaml配置就可以执行我们的构建命令，并且保存每次的构建结果。那么runner就是给我们跑命令的机器环境（可以是虚拟机，docker容器…..） GitLab-CI与GitLab-Runner 项目生产环境依赖锁定 为什么要锁定当前目录生产依赖(node_modules),因为我要确定runner的环境要与开发一致，这样构建的结果才能与开发一致。这是我需要解决的事情，但是还有一个原因希望我的项目环境依赖是固定的，方便迁移开发，不受外部原因的影响。 从 left-pad 事件我们可以学到什么? 配置gitlab-runner runner 一般需要运维去配置，如果懂一些简单的linux系统的话。自己也是可以配置一个项目的runner。讲一下配置的项目runner中遇到的一些事情： 先要在Specific Runner(CentOs.6.8)机器上安装gitlab-ci-multi-runner curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bashyum install gitlab-ci-multi-runner 在Gitlab上注册你的runner机器 gitlab-ci-multi-runner register注册的gitlab-runner的机器默认是以gitlab-runner身份默认登录runner机器，所以要确保相对应的用户有node,npm相关软件执行权限 锁定项目依赖资源表 现有的前端大而全，都会依赖一些构建工具。前端研发部采用的是fis流程，整套流程实验证明是很有价值的。但是会有一部分瑕疵：无人维护、插件质量，Bug数总量，等等。但我们现有的fis流程跑的很溜的时候， 迁移到其他开发环境是否同样顺呢？ 不会的 ，不同的环境受到网络，node，npm版本影响，都会出现各种问题，最大的问题是可能出现，npm中的软件包会经常改变依赖版本，这样的话就需要我们锁定当前健康的构建依赖。 解决方案：npm shrinkwrap锁定当前的依赖关系npm shrinkpack下载当前依赖的node_module/*.tar包npm-shrinkwrap.json&amp;npm_shrinkwrap/提交至gitlabgit co &amp; npm i这个时候你会发现下载数据非常快，因为直接从tar包中安装解压依赖。 从 left-pad 事件我们可以学到什么? 文档历史 write by Alex Lin at 2017-01-12","tags":[{"name":"开发流程","slug":"开发流程","permalink":"www.fudoor.net/tags/开发流程/"},{"name":"持续部署","slug":"持续部署","permalink":"www.fudoor.net/tags/持续部署/"}]}]